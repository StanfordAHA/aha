from helpers import *

from configs import *

########################################################################
class Tests:

    configs = {}
    for c in Configs.config_name_list:
        configs[c] = Configs.configs[c]

    # ------------------------------------------------------------------------
    # List of tests that can run with E64 mode
    # ------------------------------------------------------------------------
    E64_supported_tests = [
            "apps/pointwise",
            "apps/pointwise_mu_io",
            "conv5_x",
            "apps/avgpool_layer_fp",
            "apps/mat_vec_mul_fp",
            "apps/maxpooling_dense_rv_fp",
            "apps/fully_connected_layer_fp",
            "apps/pointwise_custom_packing",
            "apps/pointwise_custom_place_multibank",
            "apps/get_e8m0_scale_test_fp",
            "apps/get_apply_e8m0_scale_fp",
            "apps/zircon_residual_relu_fp",
            "apps/zircon_nop",
            "apps/zircon_psum_reduction_fp",
            "apps/zircon_dequantize_relu_fp"
    ]

    # List of tests that can run with E64 multi_bank mode,
    E64_MB_supported_tests = [
            "apps/pointwise",
            "apps/pointwise_mu_io",
            "apps/pointwise_custom_place_multibank",
            "apps/get_e8m0_scale_test_fp",
            "apps/get_apply_e8m0_scale_fp",
            "apps/avgpool_layer_fp",
            "apps/mat_vec_mul_fp",
            "apps/maxpooling_dense_rv_fp",
            "apps/fully_connected_layer_fp",
            "apps/zircon_residual_relu_fp",
            "apps/zircon_nop",
            "apps/zircon_psum_reduction_fp",
            "apps/zircon_dequantize_relu_fp"
    ]

    # -----------------------------------------------------------------------------------
    # skip_cgra_map: These tests skip CGRA mapping and pnr to save time.  We assume that
    # the collateral was generated by a prior test. This means certain tests must be run
    # in order e.g. map/pnr for resnet18-mod17-kernel0 can also be used for kernels 1,2,3,...
    # ------------------------------------------------------------------------------------
    # FIXME/TODO can replace this mechanism with a simple "if test ~ /kernel/ and test ~~ /kernel0... in regress.py...right?
    # ------------------------------------------------------------------------------------
    skip_cgra_map = [
        "resnet18-conv2d_mx_default_16 -> zircon_nop_post_conv5_x_kernel1_RV_E64_MB",
        "resnet18-submodule_17 -> zircon_residual_relu_fp_post_conv5_x_kernel1_RV_E64_MB",
        "resnet18-submodule_17 -> zircon_residual_relu_fp_post_conv5_x_kernel2_RV_E64_MB",
        "resnet18-submodule_17 -> zircon_residual_relu_fp_post_conv5_x_kernel3_RV_E64_MB",
        "resnet18-submodule -> zircon_dequantize_relu_fp_post_conv1_kernel1_RV_E64_MB",
        "resnet18-submodule -> zircon_dequantize_relu_fp_post_conv1_kernel2_RV_E64_MB",
        "resnet18-submodule -> zircon_dequantize_relu_fp_post_conv1_kernel3_RV_E64_MB",
    ]

    # ------------------------------------------------------------------------------------
    # Methods begin here
    # ------------------------------------------------------------------------------------
    def __init__(self, testname="BLANK", zircon=True):

        # Initialize local vars with default group names
        self.__dict__.update(Tests.template.copy())

        # Normal config groups 'fast', 'pr_aha1' etc.
        if testname in Tests.configs:
            self.__dict__.update(Tests.configs[testname])

        # json strings
        elif self.detect_and_process_json(testname):
            return

        # yaml strings
        elif self.detect_and_process_yaml(testname):
            return

        else:
            ########################################################################
            # FIXME This option exists solely to support the existing 'app' utility.
            # Can delete when/if 'app' gets updated to use something better
            # (e.g. command-line or file-indirect json / yaml)
            self.process_file(testname)
            return

    def process_file(self, config):
        '''
        # Read a custom config from external file <config>.py
        # E.g. if we find a config file '/aha/aha/util/regress_tests/custom4485.py' containing
        #   "if True:
        #       width, height = 4, 2
        #       glb_tests = [ 'tests/pointwise' ]"
        # then 'aha regress custom4485' would run a 4x2 pointwise test.
        '''
        import os, sys

        # Canonicalize filename (must have .py extension)
        # and module name (must *not* have .py extension)
        filename = config if config[-3:] == '.py' else config+'.py'
        module = filename[:-3]  # Module name is filename with .py extension stripped off

        # Find the file
        print(f"Is {config} a python file in our search path?")
        for p in sys.path:
            fullpath = p + '/' + filename
            if os.path.exists(fullpath): break
            else: fullpath = False

        if not fullpath:
            print(f"\nCould NOT find {filename} in {sys.path=}", flush=True)
            exit(13)

        # print(f"- Yes! Found {fullpath}\n")
        print(f"- Yes! Found module '{module}' in dir '{p}'\n")

        # Use python3 to see if file has correct syntax
        from subprocess import run, PIPE
        print("Is it a *parsable* python file? ", flush=True)
        p = run(f'python3 {filename}', shell=True, stderr=sys.stderr)
        sys.stdout.flush()
        if p.returncode: exit(p.returncode)
        else: print("Yes!\n")

        import importlib
        print("Load the module and use its local vars as config")
        md = importlib.import_module(module).__dict__
        config_dict = Tests.template.copy()
        for key in config_dict:
            if key in md: config_dict[key] = md[key]

        # Update self parms and return
        self.__dict__.update(config_dict)
        return

    def prefix_lines(lines, prefix):
        'Attach the indicated prefix to each line in "lines"'
        return prefix + lines.replace('\n', '\n'+prefix)

    # Json string as config e.g. '{"width":8,"height":8,"glb_tests":["apps/pointwise"]}'
    def detect_and_process_json(self, config):
        '''if "config" is a parsable json string, add it to selfdict and return True'''
        try:    config_dict = json.loads(config)
        except: return False
        assert type(config_dict) == dict
        print(f"Found json string:\n{Tests.prefix_lines(config, '    ')}\n")
        self.__dict__.update(config_dict)
        return True

    # Yaml string as config e.g. "width: 8\nheight: 8\nglb_tests:\n- apps/pointwise"
    def detect_and_process_yaml(self, config):
        '''if "config" is a parsable yaml string, add it to selfdict and return True'''
        try:
            config_dict = yaml.safe_load(config)
            assert type(config_dict) == dict
        except: return False
        print(f'{config_dict=}')
        print(f"Found yaml string:\n{Tests.prefix_lines(config, '    ')}\n")
        self.__dict__.update(config_dict)
        return True
    
    def show_config(config_name='', zircon=True):
        # Dump regression suite contents in compact form e.g. show_config('fast'):
        #
        # fast    sparse_tests   vec_identity             8x8 --removed 4 --mu 8
        # fast    glb_tests      apps/pointwise           8x8 --removed 4 --mu 8
        # fast    glb_tests      apps/pointwise_RV_E64    8x8 --removed 4 --mu 8
        # fast    glb_tests      apps/pointwise_RV_E64_MB 8x8 --removed 4 --mu 8
        # fast    glb_tests_fp   tests/fp_pointwise       8x8 --removed 4 --mu 8

        # Find config and populate it with default keys from template
        d = Tests.template.copy()
        d.update(Tests.configs[config_name])

        (w,h) =  (d['width'], d['height'])
        (col,mu) = (d["cols_removed"], d["mu_oc_0"])

        # Setup up the format string for parms e.g. "8x8 --removed 4 --mu 8"
        size = "%sx%s" % (w,h)                       # "8x8"
        zparms = " --removed %s --mu %s" % (col,mu)  # "--removed 4 --mu 8"
        if zircon: parms = size + zparms
        else:      parms = size + ' --no-zircon'

        not_groups = ("width", "height", "cols_removed", "mu_oc_0")
        for group in d:
            if not d[group]:               continue  # Dont care about empty sets
            if group in not_groups:        continue  # Not a group
            if "supported_tests" in group: continue  # Also not a group
            for app in d[group]:
                fmt = "%-12s %-16s %-32s %-s"
                print(fmt % (config_name, group, app, parms))
                # rval += (fmt % (config_name, group, app, d["app_parms"]))


    # NEW CONFIGS



# Every time someone tries to import this class, it triggers this
# quick check to make sure that no configs have redundant apps

errors = ''
for config_name in Tests.configs:
    DBG=0
    if DBG: print('\n', config_name)
    config = Tests.configs[config_name]
    lists = [key for key in config if type(config[key]) is list]
    for group in lists:
        apps = config[group]
        if DBG: print(f'    Config {config_name} has list {key}')
        for app in set(apps):  # Use set to prevent duplicate checks
            n_app = apps.count(app)
            if n_app > 1:
                errors += f"    ERROR: Config {config_name}[{group}] has {n_app} copies of '{app}'\n"

assert not errors, 'Found duplicate apps, see ERROR messages above\n\n' + errors

print("HELL OH!")

import sys
print(sys.argv)
if '--test' in sys.argv:
    print("HELLO TEST NURSE!")
    print("fast:", json.dumps(Tests.configs['fast'], indent=4))
