import copy
import os
import sys
import glob
import shutil
from pathlib import Path
import subprocess
import json
import re


def add_subparser(subparser):
    parser = subparser.add_parser(Path(__file__).stem, aliases=['halide'], description='AHA flow command for doing C simulation of a halide application, scheduling the application using Clockwork, and mapping it to PE and MEM tiles')
    parser.add_argument("app", help="Required parameter specifying which halide application to compile")
    parser.add_argument("--sim", action='store_true', help="Additionally runs the clockwork verilator simulation")
    parser.add_argument("--log", action="store_true", help="Creates a log for command output")
    parser.add_argument("--chain", action="store_true", help="Uses a chain structure for arithmetic reduction operations rather than a tree structure")
    parser.add_argument("--layer", type=str, help="Specifies layer parameters if running 'aha halide apps/resnet_output_stationary', options for LAYER are in application_parameters.json")
    parser.add_argument("--env-parameters", type=str, help="Specifies which environmental parameters to use from application_parameters.json, options for ENV_PARAMETERS are in application_parameters.json")
    parser.add_argument("--mu-test", type=str, help="Specifies the test to run on the external voyager matrix unit. This collateral for running this test will be generated by the voyager compiler. If not specified, the test will not be run.")
    parser.add_argument("--voyager-cgra-test", type=str, help="Specifies a standalone vector unit test. If not specified, the test will not be run.")
    parser.add_argument("--skip-cgra-map", action="store_true", help="Skips CGRA mapping for the application. Assumes mapping collateral has previously been generated.")
    parser.add_argument("--voyager-gold-model-only", action="store_true", help="Only run voyager for the purpose of generating gold data.")
    parser.add_argument("--skip-env-vars", action="store_true", help="Skips loading environmental variables from application_parameters.json")
    parser.set_defaults(dispatch=dispatch)


def subprocess_call_log(cmd, cwd, env, log, log_file_path, use_shell=False):
    if log:
        print("[log] Command  : {}".format(" ".join(cmd)))
        print("[log] Log Path : {}".format(log_file_path), end="  ...", flush=True)
        with open(log_file_path, "a") as flog:
            subprocess.check_call(
                cmd,
                cwd=cwd,
                env=env,
                stdout=flog,
                stderr=flog,
                shell=use_shell
            )
        print("done")
    else:
        subprocess.check_call(
            cmd,
            cwd=cwd,
            env=env,
            shell=use_shell
        )


def load_environmental_vars(env, app, layer=None, env_parameters=None):
    filename = os.path.realpath(os.path.dirname(__file__)) + "/application_parameters.json"
    new_env_vars = {}
    app_name = str(app) if layer is None else str(layer)

    if not os.path.exists(filename):
        print(f"{filename} not found, not setting environmental variables")
    else:
        fin = open(filename, 'r')
        env_vars_fin = json.load(fin)
        if "global_parameters" in env_vars_fin:
            if env_parameters is None or str(env_parameters) not in env_vars_fin["global_parameters"]:
                new_env_vars.update(env_vars_fin["global_parameters"]["default"])
            else:
                new_env_vars.update(env_vars_fin["global_parameters"][str(env_parameters)])

        if app_name in env_vars_fin:
            if env_parameters is None or str(env_parameters) not in env_vars_fin[app_name]:
                new_env_vars.update(env_vars_fin[app_name]["default"])
            else:
                new_env_vars.update(env_vars_fin[app_name][str(env_parameters)])

    # We always set compute pipelining to 0 for dense ready-valid case
    if os.getenv("DENSE_READY_VALID") == "1":
        new_env_vars["PIPELINED"] = "0"

    # No need for each var to have its own '---' group, just use '+++' instead of '---'
    print(f"--- Setting environment variables for {app}")
    for n, v in new_env_vars.items():
        print(f"... {n} = {v}")
        env[n] = v



def voyager_run_layer(model, layer):
    # Activate conda environment and run compiler. Deactivate when done
    print(f"\nRunning voyager compiler for layer {layer} of {model}...\n")

    compile_cmd = f"DATATYPE=MXINT8 IC_DIMENSION=64 OC_DIMENSION=32 CLOCK_PERIOD=5 python run_regression.py --models {model} --sims fast-systemc --num_processes 32 --tests {layer} "

    # If the voyager test fails, regression exits with an error.
    original_dir = os.getcwd()
    try:
        os.chdir("/aha/voyager/")
        ret = os.system(
            f'bash -c \''
            f'source ~/.bashrc && '
            f'source /cad/modules/tcl/init/bash && '
            f'module load catapult/2024.2_2 && '
            f'eval "$(conda shell.bash hook)" && '
            f'conda activate ./.conda-env && '
            f'{compile_cmd} && '
            f'module unload catapult/2024.2_2 && '
            f'conda deactivate\''
        )
    finally:
        os.chdir(original_dir)

    exit_code = ret >> 8
    if exit_code != 0:
        print(f"\033[91mERROR: Voyager compiler failed with exit code {exit_code}. Please check the logs for more details.\033[0m")
        # sys.exit(exit_code)


def dispatch(args, extra_args=None):
    args.app = Path(args.app)
    env = copy.deepcopy(os.environ)
    env["COREIR_DIR"] = str(args.aha_dir / "coreir")
    env["COREIR_PATH"] = str(args.aha_dir / "coreir")
    env["LAKE_PATH"] = str(args.aha_dir / "lake")
    env["CLOCKWORK_PATH"] = str(args.aha_dir / "clockwork")
    halide_dir = args.aha_dir / "Halide-to-Hardware"
    app_dir = halide_dir / Path("apps/hardware_benchmarks") / args.app
    env["LAKE_CONTROLLERS"] = str(app_dir / "bin")
    env["LAKE_STREAM"] = str(app_dir / "bin")

    if not args.skip_env_vars:
        load_environmental_vars(env, args.app, layer=args.layer, env_parameters=args.env_parameters)

    app_name = args.app.name
    run_sim = args.sim
    chain = args.chain
    mu_test = args.mu_test
    voyager_cgra_test = args.voyager_cgra_test

    log_path = app_dir / Path("log")
    log_file_path = log_path / Path("aha_map.log")
    if args.log:
        subprocess.check_call(["mkdir", "-p", log_path])
        subprocess.check_call(["rm", "-f", log_file_path])

    #############################################################################################
    #-----MAP CONV/MATMUL TO MATRIX UNIT OR GENERATE COLLATERAL FOR STANDALONE CGRA TEST-------#
    #############################################################################################
    # Call voyager compiler where necessary
    is_mu_test = mu_test is not None and mu_test != ""
    is_voyager_standalone_cgra_test = voyager_cgra_test is not None and voyager_cgra_test != ""
    is_voyager_app = is_mu_test or is_voyager_standalone_cgra_test
    if is_voyager_app:
        voyager_test_fullname = mu_test if is_mu_test else voyager_cgra_test
        model = voyager_test_fullname.split("-")[0]
        layer = voyager_test_fullname.split("-")[1]

        voyager_collateral_path = "/aha/voyager/compiled_collateral"
        voyager_app_base_path = f"{voyager_collateral_path}/{voyager_test_fullname}"
        tensor_files_path = f"{voyager_app_base_path}/tensor_files"
        compare_path = f"{voyager_app_base_path}/compare"

        subprocess.check_call(["mkdir", "-p", voyager_app_base_path])
        subprocess.check_call(["mkdir", "-p", tensor_files_path])
        subprocess.check_call(["mkdir", "-p", compare_path])

        if is_mu_test:
            print(f"\033[92mCompiling and mapping {layer} of {model} to run on the voyager matrix unit...\033[0m")
        else:
            print(f"\033[92mGenerating standalone CGRA test collateral for {layer} of {model} using voyager...\033[0m")
        print(f"\nVoyager collateral will be generated in: {voyager_app_base_path}\n")

        # Create conda environment
        subprocess_call_log(
            cmd=["make", "create-env"],
            cwd=args.aha_dir / "voyager",
            env=env,
            log=args.log,
            log_file_path=log_file_path
        )

        # Set necessary env vars
        # PATH
        voyager_path = "/aha/voyager/VOYAGER_PATH.txt"
        if not os.path.isfile(voyager_path):
            sys.exit(f"Error: File '{voyager_path}' does not exist. It should have been generated during make create-env")
        with open(voyager_path, 'r') as f:
            first_line = f.readline().strip()
        os.environ['PATH'] = first_line
        print(f"\nPATH for voyager has been set to: {os.environ['PATH']}\n")

        # LD_LIBRARY_PATH
        conda_prefix = "/aha/voyager/.conda-env"
        ld_library_path = os.environ.get("LD_LIBRARY_PATH", "")
        new_ld_library_path = f"/cad/mentor/2024.2_2/Mgc_home/lib:/cad/mentor/2024.2_2/Mgc_home/shared/lib:{conda_prefix}/lib:{ld_library_path}"
        os.environ["LD_LIBRARY_PATH"] = new_ld_library_path
        print(f"\nLD_LIBRARY_PATH for voyager has been set to: {os.environ['LD_LIBRARY_PATH']}\n")

        # Other
        os.environ["PROJECT_ROOT"] = "/aha/voyager"
        os.environ["CODEGEN_DIR"] = "test/compiler"

        # Run voyager compiler for the specified layer
        voyager_run_layer(model, layer)

        if not args.voyager_gold_model_only:
            # Parse the dnnLayer tensors and write them to tensor_files directory
            print(f"\nParsing tensors for layer {layer} of {model}...\n")

            per_tensor_scaling = "PER_TENSOR_SCALING" in env and env["PER_TENSOR_SCALING"] == "1"

            parse_tensor_args = [
                "--model", model,
                "--layer", layer,
                "--datatype", "MXINT8",
                "--h2h_dir", app_dir,
            ]

            if per_tensor_scaling:
                parse_tensor_args.append("--per-tensor-scaling")

            if not(is_mu_test):
                parse_tensor_args.append("--standalone-cgra-test")

            subprocess_call_log(
                cmd=[sys.executable,
                        f"{args.aha_dir}/voyager/scripts/aha_flow/parse_dnnLayer_tensors.py",
                        *parse_tensor_args
                        ],
                cwd=args.aha_dir / "voyager",
                log=args.log,
                log_file_path=log_file_path,
                env=env
            )

            if per_tensor_scaling:
                per_tensor_scales_file = f'/aha/voyager/compiled_collateral/{model}-{layer}/tensor_files/per_tensor_scales.txt'
                assert os.path.exists(per_tensor_scales_file), f"ERROR: {per_tensor_scales_file} not found, something went wrong in parse_dnnLayer_tensors.py"
                with open(per_tensor_scales_file, 'r') as f:
                    for line in f:
                        line_components = line.strip().split(': ')
                        scale_name = line_components[0]
                        scale_value = line_components[1]
                        if 'dequantize_scale' in scale_name:
                            env['DEQUANT_SCALE'] = scale_value
                        elif 'quantize_scale' in scale_name and not('dequantize_scale' in scale_name):
                            env['QUANT_SCALE'] = scale_value

        # For conv1, we want the gold-check to be done using submodule_1's gold
        # Submodule 1 and submodule of resnet18 should really be fused but cannot be due to complications in the quantized-training module
        if layer == "submodule_1":
            subprocess.check_call(["mv", "/aha/voyager/gold_activation.txt", "/aha/voyager/gold_activation_submodule_1.txt"])

        if layer == "submodule":
            subprocess.check_call(["mv", "/aha/voyager/gold_activation_submodule_1.txt", "/aha/voyager/gold_activation.txt"])

        if not args.voyager_gold_model_only:
            subprocess_call_log(
                cmd=[sys.executable,
                        f"{args.aha_dir}/voyager/scripts/aha_flow/adjust_voyager_gold.py",
                        "--input", f"/aha/voyager/gold_activation.txt",
                        "--output", f"/aha/voyager/gold_activation.txt"
                        ],
                cwd=args.aha_dir / "voyager",
                log=args.log,
                log_file_path=log_file_path,
                env=env
            )

            # Move collateral to desired folders
            if is_mu_test:
                subprocess.check_call(["mv", "/aha/voyager/serialized_matrix_params.txt", voyager_app_base_path])
            systemC_comparison_files = glob.glob("/aha/voyager/*systemC.txt")
            subprocess.check_call(["mv"] + systemC_comparison_files + [compare_path])
            subprocess.check_call(["mv", "/aha/voyager/gold_activation.txt", compare_path])
            gold_scale_path = "/aha/voyager/gold_scale.txt"
            if os.path.exists(gold_scale_path):
                subprocess.check_call(["mv", gold_scale_path, compare_path])
            subprocess.check_call(["mv", "/aha/voyager/tensor_metadata.json", voyager_app_base_path])
            if is_mu_test:
                subprocess.check_call(["mv", "/aha/voyager/output_tiling.txt", voyager_app_base_path])

    #####################################
    #-----MAP CGRA TEST TO CGRA -------#
    #####################################
    skip_cgra_map = args.skip_cgra_map
    if skip_cgra_map:
        print(f"\033[93mINFO: Skipping CGRA mapping for {app_name} as per settings in regress.py. Assuming mapping collateral has previously been generated...\033[0m")
    else:
        print(f"\033[92mMapping {app_name} to CGRA...\033[0m")
        if "handcrafted" in str(args.app):
            # Generate pgm Images
            subprocess_call_log(
                cmd=["make", "-C", str(app_dir), "bin/input.raw", "bin/output_cpu.raw"],
                cwd=args.aha_dir / "Halide-to-Hardware",
                env=env,
                log=args.log,
                log_file_path=log_file_path
            )

            os.rename(
                app_dir / "bin/output_cpu.raw", app_dir / "bin/gold.raw",
            )

        else:
            # Raw Images
            subprocess_call_log(
                cmd=["make", "-C", str(app_dir), "compare", "bin/input_cgra.pgm", "bin/output_cgra_comparison.pgm"],
                cwd=args.aha_dir / "Halide-to-Hardware",
                env=env,
                log=args.log,
                log_file_path=log_file_path
            )

            os.rename(
                app_dir / "bin/input_cgra.pgm", app_dir / "bin/input.pgm",
            )
            os.rename(
                app_dir / "bin/output_cgra_comparison.pgm", app_dir / "bin/gold.pgm",
            )


        # Copy path_balance.json if using POND_PATH_BALANCING
        if 'POND_PATH_BALANCING' in env and env['POND_PATH_BALANCING'] == '1':
            layer_path_balance_folder = f"{app_dir}/path_balancing_configs"
            assert os.path.exists(layer_path_balance_folder), f"ERROR: path_balancing_configs folder does not exist in {app_dir}, cannot copy path_balance.json"

            if mu_test is None or mu_test == "":
                layer_path_balance_json = os.path.join(layer_path_balance_folder, "path_balancing.json")
                assert os.path.exists(layer_path_balance_json), f"ERROR: path_balancing.json not found in {layer_path_balance_folder}."
            else:
                layer_path_balance_json = os.path.join(layer_path_balance_folder, f"{model}-{layer}_path_balancing.json")
                assert os.path.exists(layer_path_balance_json), f"ERROR: {model}_{layer}_path_balancing.json not found in {layer_path_balance_folder}."
            os.system(f"cp {layer_path_balance_json} {app_dir}/bin/path_balancing.json")

        if not chain:
            subprocess_call_log(
                cmd=["make", "-C", str(app_dir), "tree"],
                cwd=args.aha_dir / "Halide-to-Hardware",
                env=env,
                log=args.log,
                log_file_path=log_file_path
            )

        if run_sim:
            subprocess_call_log(
                cmd=["make", "-C", str(app_dir), "test-mem"],
                cwd=args.aha_dir / "Halide-to-Hardware",
                env=env,
                log=args.log,
                log_file_path=log_file_path
            )
        else:
            subprocess_call_log(
                cmd=["make", "-C", str(app_dir), "map"],
                cwd=args.aha_dir / "Halide-to-Hardware",
                env=env,
                log=args.log,
                log_file_path=log_file_path
            )

        # move to apps/bin
        clkwrk_design = app_name + "/" + app_name + "_garnet.json"
        if os.path.exists(str(app_dir / "bin/map_result" / clkwrk_design)):
            shutil.copyfile(str(app_dir / "bin/map_result" / clkwrk_design), str(app_dir / "bin/design_top.json"))
